<!DOCTYPE html>
<html lang="en-us">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>Cindy Cao&#39;s Portfolio</title>
<meta name="description" content="Describe your website">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://cindy-cao-portfolio.netlify.app/css/bootstrap.min.css">
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:400,300,700,400italic">
<link rel="stylesheet" href="https://cindy-cao-portfolio.netlify.app/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cindy-cao-portfolio.netlify.app/css/owl.carousel.css">
<link rel="stylesheet" href="https://cindy-cao-portfolio.netlify.app/css/owl.theme.css">


  <link href="https://cindy-cao-portfolio.netlify.app/css/style.default.css" rel="stylesheet" id="theme-stylesheet">

 

  
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
        <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  


<link href="https://cindy-cao-portfolio.netlify.app/css/custom.css" rel="stylesheet">
<link rel="shortcut icon" href="https://cindy-cao-portfolio.netlify.app/img/favicon.png">


<script async src="https://www.googletagmanager.com/gtag/js?id=G-G0F7Z00VB5"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-G0F7Z00VB5', { 'anonymize_ip': false });
}
</script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"
    integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"
    integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"
    integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false }
            ]
        });
    });
</script>
</head>
<body>
  <div id="all">
      <div class="container-fluid">
          <div class="row row-offcanvas row-offcanvas-left">
              <div id="sidebar" class="col-xs-6 col-sm-4 col-md-3 sidebar-offcanvas">
  <div class="sidebar-content">
    <h1 class="sidebar-heading"><a href="https://cindy-cao-portfolio.netlify.app/">Cindy Cao&#39;s Portfolio</a></h1>
    
      <p class="sidebar-p">I am a creative illustrator and graphic designer with more than 10 years of experience.</p>
    
      <p class="sidebar-p">Originally from Beijing, currently based in Vancouver.</p>
    
      <p class="sidebar-p">Engine: Unity 3D, Unreal Engine</p>
    
      <p class="sidebar-p">DCC Tools: Maya, 3ds Max, Cinema 4D, Blender, Substance Designer</p>
    
      <p class="sidebar-p">Motion Pictures: Silverstack, DaVinci Resolve, Final Cut Pro, Premiere</p>
    
      <p class="sidebar-p">Miscellaneous: Photoshop, Illustrator, After Effects, Lightroom</p>
    
    <ul class="sidebar-menu">
      
        <li><a href="https://cindy-cao-portfolio.netlify.app/portfolio/">Home</a></li>
      
        <li><a href="https://cindy-cao-portfolio.netlify.app/about/">About</a></li>
      
        <li><a href="https://cindy-cao-portfolio.netlify.app/contact/">Get in touch</a></li>
      
    </ul>
    <p class="social">
  
  
  
  
  
  <a href="mailto:xinyicindycao@163.com" data-animate-hover="pulse" class="email" title="E-mail">
    <i class="fa fa-envelope"></i>
  </a>
  
  
  <a href="https://www.linkedin.com/in/cindycao15/" data-animate-hover="pulse" class="external" title="LinkedIn" rel="me">
    <i class="fa fa-linkedin"></i>
  </a>
  
  
  
  <a href="https://github.com/CIndyCao15" data-animate-hover="pulse" class="external" title="GitHub" rel="me">
    <i class="fa fa-github"></i>
  </a>
  
  
  
  
</p>


    <div class="copyright">
      <p class="credit">
        
          &copy;2024 Cindy Cao |
        
        Template by <a href="https://bootstrapious.com/free-templates" class="external">Bootstrapious.com</a>

&amp; ported to Hugo by <a href="https://github.com/kishaningithub">Kishan B</a>

      </p>
    </div>
  </div>
</div>

              
<div class="col-xs-12 col-sm-8 col-md-9 content-column white-background">
  <div class="small-navbar visible-xs">
  <button type="button" data-toggle="offcanvas" class="btn btn-ghost pull-left"> <i class="fa fa-align-left"> </i>Menu</button>
  <h1 class="small-navbar-heading"><a href="https://cindy-cao-portfolio.netlify.app/">Cindy Cao&#39;s Portfolio</a></h1>
</div>

  <div class="row">
    <div class="col-lg-8">
      <div class="content-column-content">
         <h1>[ #Project 2 ] Unity VR - The Peach Blossom Spring - Chinese brush painting effect</h1>
         <hr>
<div class="table">
    <div class="row">
        <div class="cell border-right col-1">
            <strong>ROLE</strong><br>
            Team Leader<br><br>
            <strong>YEAR</strong><br>
            2022<br><br>
            <strong>TOOLS USED</strong><br>
            Unity, Photoshop<br><br>
            <strong>PLATFORM</strong><br>
            Oculus Rift S
        </div>
        <div class="cell border-right col-2">
            <strong>RESPONSIBILITY</strong>
            <ol>
                <li>
                    As a technical artist, I am responsible for the Chinese brush painting rendering scheme and optimization. I am also responsible for the final visual presentation of the game. and propose technical solutions for programmers to implement.
                </li>
                <li>
                    As a designer, I design and implement the VR interaction scheme, and complete the UI design.
                </li>
                <li>
                    As a programmer, I write scripts concerning gameplay / UI /  visual effects with team member.
                </li>
            </ol>
        </div>
        <div class="cell col-3">
            <strong>DESCRIPTION</strong><br>
            The VR experience focuses on Climate Emergency. The first scene shows a utopian scene from a long time ago, the second scene shows the current Climate Emergency facing humanity (inspired by the Chongqing wildfire in 2022), and the third scene shows a cyberspace, where the player can make a commitment.
        </div>
    </div>
</div>
<hr>
<blockquote>
<p>There was a time when meadow, grove, and stream,
<br>
The earth, and every common sight,
<br>
To me did seem
<br>
Apparelled in celestial light,
<br>
The glory and the freshness of a dream.
<br>
It is not now as it hath been of yore;—
<br>
Turn wheresoe&rsquo;er I may,
<br>
By night or day.
<br>
The things which I have seen I now can see no more.</p>
</blockquote>
<p>
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/NW-UrDA5nq0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="Unity ink painting effect rendering VR scene"></iframe>
</div>

<br></p>
<p><em><a href="https://skfb.ly/6RnWL">&ldquo;The Creation of Adam&rdquo;</a> by Loïc Norgeot is licensed under <a href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution</a>.</em></p>
<p>You can find the playable build shown in the video <a href="https://drive.google.com/drive/folders/1O-hnS8qAkfEFtwk0FRUm3RVPHHwUvIW8?usp=sharing">here</a>. The game runs on Oculus Rift S, so if you don&rsquo;t have the VR headset I&rsquo;m afraid you won&rsquo;t get the full experience. You can still use the spacebar to switch between scenes, which is a backdoor I left, but other interactions (moving, teleporting, picking up props, dialogue, etc.) are not available.</p>
<p>Chinese brush painting rendering is the part where I spend the most effort. For the brush painting-only version, please check out my other video:</p>
<p>
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/YdPf6S08NT0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="Unity ink painting effect rendering VR scene"></iframe>
</div>

<br></p>
<p>Using Unity&rsquo;s built-in pipeline, I implemented this project in the style of Chinese brush painting.</p>
<p>I first analyze the aesthetic characteristics of landscape and figure paintings, and then proposed two methods for Chinese brush painting effect, one for characters and one for mountains and rocks. I use Oculus Rift S as a development device and developed this project based on the new XR plug-in architecture provided by Unity 2019.3.0, and finally use Oculus Debug Tool and Unity UPR (Unity Performance Report) for performance testing.</p>
<p><a href="/img/portfolio/Unity-ink-painting-effect-rendering-VR-scene-1.png"><img src="/img/portfolio/Unity-ink-painting-effect-rendering-VR-scene-1.png" alt="Snapshot 1 of Unity ink painting effect rendering VR scene"></a></p>
<p><a href="/img/portfolio/Unity-ink-painting-effect-rendering-VR-scene-2.png"><img src="/img/portfolio/Unity-ink-painting-effect-rendering-VR-scene-2.png" alt="Snapshot 2 of Unity ink painting effect rendering VR scene"></a></p>
<p>This picture shows what the models look like originally in Unity Standard shader.</p>
<p><a href="/img/portfolio/Unity-ink-painting-effect-rendering-VR-scene-3.png"><img src="/img/portfolio/Unity-ink-painting-effect-rendering-VR-scene-3.png" alt="Snapshot 3 of Unity ink painting effect rendering VR scene"></a></p>
<h4 id="catalog">Contents</h4>
<ol>
<li><a href="#Inspiration">Inspiration - about Climate Emergency</a></li>
<li><a href="#Design-Concept">Design Concept</a></li>
<li><a href="#Chinese-Brush-Painting-Rendering">Chinese Brush Painting Rendering</a>
<ol>
<li><a href="#Aesthetic-Characteristics-of-Chinese-Brush-Painting">Aesthetic Characteristics of Chinese Brush Painting</a></li>
<li><a href="#Chinese-Brush-Painting-Mountain-and-Rock-Rendering-Scheme">Chinese Brush Painting Mountain &amp; Rock Rendering Scheme</a>
<ol>
<li><a href="#Contour-rendering">Contour rendering based on dual-pass Shell Method</a></li>
<li><a href="#Internal-coloring">Internal coloring with a shading method based on Half-Lambert lighting model and diffuse warping function</a></li>
<li><a href="#Rubbing">Rubbing simulation based on model curvature</a></li>
<li><a href="#Stroke-texture">Stroke texture (feathering and spreading)</a></li>
</ol>
</li>
<li><a href="#Chinese-Brush-Painting-Character-Rendering-Scheme">Chinese Brush Painting Character Rendering Scheme</a></li>
</ol>
</li>
<li><a href="#Unity-VR">Unity VR Integration</a></li>
<li><a href="#Gameplay">Gameplay</a>
<ol>
<li><a href="#Scripts">Scripts  Architecture Overview</a></li>
<li><a href="#Gameplay-Scripts">Analysis of Gameplay Scripts</a></li>
</ol>
</li>
<li><a href="#UI">UI Design</a></li>
<li><a href="#Transition">Scene Transition Design</a></li>
</ol>
<p>❤ <a href="#Blooper">Blooper</a></p>
<h2 id="Inspiration">Inspiration - about Climate Emergency</h2>
<p>In the past two years, China has experienced an extremely severe climate emergency. The unprecedented heavy rains and floods in Henan Province in 2021 affected 14.8 million people and resulted in 398 deaths and disappearances. The capital city of Zhengzhou, with a population of nearly 13 million, received nearly the annual average rainfall in just three days. The hourly rainfall intensity between 4 p.m. and 5 p.m. on July 20 <strong>broke the historical record for extreme rainfall in mainland China</strong>. In August 2022, Chongqing was hit by an extreme weather event of consecutive high temperatures and sunny days, which led to a forest fire. The flames and thick smoke lit up the night sky, and Chongqing was sleepless throughout the night.</p>
<p><figure><img src="/img/portfolio/Unity-ink-fire.png" width="500px"/>
</figure>

<br></p>
<p>Shocked by the news images, I decided to create a VR experience depicting the scene of a forest fire at night.</p>
<p>Living in cities with air conditioning, central heating, skyscrapers, and glass corridors, we often overlook the pain in distant places. What we are familiar with seems to be a stable life, but it is actually a phantom created by the market economy, long-distance logistics, and social systems. Through creating this VR experience, I hope to draw attention to the urgent need to face the climate emergency. Otherwise, the sword of Damocles will eventually fall, and no one will be spared.</p>
<h2 id="Design-Concept">Design Concept</h2>
<p>In ancient Chinese landscape philosophy, the concept of <em>&ldquo;unity of man and nature&rdquo;</em> (天人合一) was emphasized, where man and nature coexist in harmony. In landscape painting, the idea of <em>&ldquo;reclining and traveling&rdquo;</em> (卧游) was used to fully appreciate the beauty of mountains and rivers. The concept of <em>&ldquo;reclining and traveling&rdquo;</em> involves a spiritual journey through cultural mediums in a fleeting moment, similar to using VR headsets to tour landscape paintings.</p>
<p>The first scene is set in spring, with a light drizzle, expressing the ancient idea of the <em>unity of man and nature</em>. After taking off the VR headset, the second scene shows a modern-day mountain fire. In this scene, six modern people wearing VR headsets seem unwilling to wake up from their own illusion, unlike the timely awakening of the player. After the player talks to them and removes their VR headsets, they immediately burn and disperse, signifying that if we do not address the climate emergency, no one will be spared in the end.</p>
<p>The scene then switches to the third scene, a holographic consciousness space with a giant sculpture of the hand from Michelangelo&rsquo;s <em>The Creation of Adam</em>. At the fingertips where God and Adam meet, consciousness flows quietly. When the player gently touches it, they also make a commitment to address the climate emergency.</p>
<h2 id="Chinese-Brush-Painting-Rendering">Chinese Brush Painting Rendering</h2>
<h3 id="Aesthetic-Characteristics-of-Chinese-Brush-Painting">Aesthetic Characteristics of Chinese Brush Painting</h3>
<p>For <strong>brush painting mountains and stones</strong>, there are two characteristics that need to be reflected:</p>
<p>1.The stone has many sides (石分三面)</p>
<p>A stone should have a sense of space and volume, and a sense of impermeability is the top priority. The two steps of &ldquo;rub (皴)&rdquo; and &ldquo;dye (染)&rdquo; are the key steps to enhance the sense of volume of rocks.</p>
<p>2.Structural use of the brush (骨法用笔)</p>
<p>When drawing the contours of an object (sketch, 勾), the technique of using a brush must be strong, thus forming the structure of the object like bones.</p>
<p><figure><img src="/img/portfolio/Unity-ink-%e6%b0%b4%e5%a2%a8%e7%94%bb%e7%89%b9%e7%82%b9%e5%88%86%e6%9e%90.jpg"/>
</figure>

<br></p>
<p>There are two very different styles of <strong>figures in Chinese brush paintings</strong>. The traditional style, such as the <em>Drunken Immortal in Splashed Ink Style</em> (泼墨仙人图) by Liang Kai of Song Dynasty, has vivid spiritual consonance and a high degree of refinement and exaggeration of the characters; the modern style, such as <em>Whisper</em> (悄悄话), is combined with pencil sketch techniques. The characters are perfectly shaped in rich details, while the background is blurred.</p>
<figure><img src="/img/portfolio/Unity-ink-%e6%b3%bc%e5%a2%a8%e4%bb%99%e4%ba%ba%e5%9b%be%e6%82%84%e6%82%84%e8%af%9d.png"
         alt="**Left**: *Drunken Immortal in Splashed Ink Style*(1200s);   **Right**: *Whisper*(1979)" width="600px"/><figcaption>
            <p><strong>Left</strong>: <em>Drunken Immortal in Splashed Ink Style</em>(1200s);   <strong>Right</strong>: <em>Whisper</em>(1979)</p>
        </figcaption>
</figure>

<p>In character rendering part, I choose to simulate modern-style brush painting characters.</p>
<p>There are four techniques of traditional Chinese brush painting: sketching, rubbing, dotting, and shading (勾、皴、点、染). Among them, &ldquo;dotting&rdquo; refers to drawing moss, which is not a necessary step for painting. Therefore, I slightly changed these four steps to &ldquo;sketching, rubbing, shading, and coloring (勾、皴、染、设色)&rdquo;, which correspond to the four parts that need to be implemented in realtime rendering: contour rendering, texture mapping/curvature, lighting model, and main texture.</p>
<p><figure><img src="/img/portfolio/Unity-ink-%e5%8b%be%e7%9a%b4%e6%9f%93%e8%ae%be%e8%89%b2.png"/>
</figure>

<br></p>
<h3 id="Chinese-Brush-Painting-Mountain-and-Rock-Rendering-Scheme">Chinese Brush Painting Mountain &amp; Rock Rendering Scheme</h3>
<p>In the Chinese brush painting mountain and rock rendering scheme, the Shell Method-based dual-pass rendering method is used to render the outline of the mountain stone, simulating the effect of dry brushes and whitewashing. The internal coloring uses a shading method based on Half-Lambert lighting model and diffuse warping function, and again uses triplanar to superimpose the stroke texture, and uses Gaussian blur to simulate the effect of ink diffusion.</p>
<h4 id="Contour-rendering">Contour rendering based on dual-pass Shell Method</h4>
<p>Traditional Shell Method offset the back of the shell geometry along the -z axis, causing the contour and object to have a strong sense of misalignment, especially at the edge of the view frustum. I eliminate this artifact by offsetting the geometry along the view direction.</p>
<figure><img src="/img/portfolio/Unity-ink-frustum.png"
         alt="Left: the view frustum; Right: the contour misalignment gets worse as the object gets closer to the edge of the viewport. This is unsatisfactory, especially in VR, when the player has a huge FOV." width="600px"/><figcaption>
            <p><strong>Left</strong>: the view frustum; <strong>Right</strong>: the contour misalignment gets worse as the object gets closer to the edge of the viewport. This is unsatisfactory, especially in VR, when the player has a huge FOV.</p>
        </figcaption>
</figure>

<p>To simulate whitewash and dry brush, the contour rendering requires two passes. Each pass samples a Perlin noise, and the vertices are offset according to the noise map. To sample a texture in the vertex shader, I use the <em>tex2Dlod</em> method in cg.</p>
<p>The comparison between my silhouette rendering scheme on the terrain and the existing scheme is as follows:</p>
<figure><img src="/img/portfolio/Unity-ink-mountainContour.png"
         alt="a) My silhouette rendering effect; b) The silhouette rendering effect in the reference. The circled area is where the stroke thickness is uneven near the edge of the frustum." width="550px"/><figcaption>
            <p>a) My silhouette rendering effect; b) The silhouette rendering effect in the reference. The circled area is where the stroke thickness is uneven near the edge of the frustum.</p>
        </figcaption>
</figure>

<h4 id="Internal-coloring">Internal coloring with a shading method based on Half-Lambert lighting model and diffuse warping function</h4>
<p>Since the mountain rock has the aesthetic characteristic of &ldquo;space and volume&rdquo;, a lighting model should be used to render the mountain rock to create a sense of volume. In an empirical lighting model, lighting consists of 3 components: diffuse, specular, and ambient lighting. Brush painting mountain and stone mainly reflects diffuse light.</p>
<p>The diffuse warp function should be a step function. It is used to divide the ink color.</p>
<div style="display: none">
<figure><img src="/img/portfolio/Unity-ink-%e6%bc%ab%e5%8f%8d%e5%b0%84%e5%85%ac%e5%bc%8f.png" width="300px"/>
</figure>

<br>
</div>
<p>$$
\begin{align}
C_{0}\left(C_{i}\right)=\begin{cases}
0.1, &amp; C_{i} \leq 0.25 \cr
0.3, &amp; 0.25 &lt; C_{i} \leq 0.55 \cr
0.7, &amp; 0.55 &lt; C_{i} \leq 0.8 \cr
1.0, &amp; C_{i} &gt; 0.8
\end{cases}
\end{align}
$$</p>
<p>Among them, <em>C<sub>i</sub></em> is the original diffuse color, which is the input color of the <em>C<sub>0</sub></em> function. In actual use, to make the transition between different colors more natural, I roughly add a transition color between adjacent gradients.</p>
<figure><img src="/img/portfolio/Unity-ink-%e6%bc%ab%e5%8f%8d%e5%b0%84%e5%87%bd%e6%95%b0%e5%9b%be%e7%89%87.png"
         alt="Diffuse warp function" width="250px"/><figcaption>
            <p>Diffuse warp function</p>
        </figcaption>
</figure>

<p>The result of this step, a shading method based on Half-Lambert lighting model and diffuse warping function, is as follows.</p>
<figure><img src="/img/portfolio/Unity-ink-%e6%bc%ab%e5%8f%8d%e5%b0%84%e7%bb%93%e6%9e%9c%e5%9b%be%e7%89%87.png" width="550px"/>
</figure>

<h4 id="Rubbing">Rubbing simulation based on model curvature</h4>
<p>Rubbing (皴) is a technique of Chinese brush painting, which is used in landscape painting to represent trees and rocks. It is mainly used to express the texture of the rocks, that is, the texture of the inner contour.</p>
<p>I use model curvature to simulate rubbing. When calculating the curvature, as the arc length approaches zero, the arc length can be approximated by the distance Δ<em>p</em> between vertices, and the rate of change of the normal Δ<em>N</em> can be used to replace the rate of change of the tangent.</p>
<figure><img src="/img/portfolio/Unity-ink-%e6%9b%b2%e7%8e%87%e8%ae%a1%e7%ae%97%e5%9b%be.jpg"
         alt="Surface curvature calculate" width="350px"/><figcaption>
            <p>Surface curvature calculate</p>
        </figcaption>
</figure>

<p>The curvature at fragment <em>i</em> can be obtained by the ratio of the vertex normal vector and the rate of change of the position coordinate relative to the <em>x</em>-axis direction and the <em>y</em>-axis direction of the view space.</p>
<div style="display:none">
<figure><img src="/img/portfolio/Unity-ink-%e6%9b%b2%e7%8e%87%e5%85%ac%e5%bc%8f.png" width="100px"/>
</figure>

<br>
</div>
<p>$$
\begin{align}
k_{i}=\frac{1}{k} \cdot \frac{\Delta N}{\Delta p}
\end{align}
$$</p>
<p>Among them, <em>k<sub>i</sub></em> is the curvature value at fragment <em>i</em>, and <em>k</em> is the curvature adjustment coefficient. Written in Unity ShaderLab, the pseudocode is as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>curvature = <span style="color:#ff0086;font-weight:bold">length</span>(<span style="color:#ff0086;font-weight:bold">fwidth</span>(viewNormal)) / (<span style="color:#ff0086;font-weight:bold">length</span>(<span style="color:#ff0086;font-weight:bold">fwidth</span>(viewPos)) * _CurveFactor);</span></span></code></pre></div>
<p>Curvature reflects the degree of change in the convexity and concavity of the object&rsquo;s surface. The larger the curvature value, the sharper the unevenness of the object&rsquo;s surface. At this point, the rubbing should be more obvious. I limit the curvature value in the range of 0 to 1, and use 1-<em>k<sub>i</sub></em> to calculate the rubbing color.</p>
<p><figure><img src="/img/portfolio/Unity-ink-%e6%9b%b2%e7%8e%87%e6%95%88%e6%9e%9c%e5%9b%be.png" width="550px"/>
</figure>

<br></p>
<p>This method based on the model curvature has its limitations in terms of use scenarios. I use the per vertex information (which is constant within a single triangle) of the normal rate of change and position to calculate the derivative. In the case of a relatively high triangle counts of a single model, the results obtained by this calculation method can meet the requirements; but in the case of a relatively low triangle count number, there will be more blocky. The solution to this artifact is:</p>
<ol>
<li>Bake the curvature information into vertex color;</li>
<li>Bake the curvature information into a curvature map;</li>
<li>Use Post Processing and render texture to blur the blocky curvature, and then blend it with other render outputs.</li>
</ol>
<figure><img src="/img/portfolio/Unity-ink-%e6%9b%b2%e7%8e%87%e5%af%b9%e6%af%94%e5%9b%be.png"
         alt="Left: No curvature; Right: With blurred curvature" width="550px"/><figcaption>
            <p><strong>Left</strong>: No curvature; <strong>Right</strong>: With blurred curvature</p>
        </figcaption>
</figure>

<p>Considering that the actual effect is not ideal, the simulation of the rubbing method was not deployed in the rendering scheme of mountains and rocks. Instead, I use triplanar and Gaussian blur to simulate the stroke texture of the rocks.</p>
<h4 id="Stroke-texture">Stroke texture (feathering and spreading)</h4>
<p>When using the one-dimensional lookup table for diffuse warp, the input is the diffuse calculated according to the Half-Lambert lighting model. Adding some randomness to this will make the final warp results feel more random.</p>
<div style="display:none">
<figure><img src="/img/portfolio/Unity-ink-%e6%bc%ab%e5%8f%8d%e5%b0%84%e5%8a%a0%e5%99%aa%e5%a3%b0%e5%85%ac%e5%bc%8f.png" width="150px"/>
</figure>

<br>
</div>
<p>$$
\begin{align}
C_{i \space new}=C_{i}+r_{i}
\end{align}
$$</p>
<p>Among them, <em>C<sub>i new</sub></em> is the new diffuse after processing, and <em>r<sub>i</sub></em> is a random value. I use Perlin noise to introduce randomness, and use a stroke texture to control the overall light and shadow. I use triplanar to sample the two textures.</p>
<p>The image below is the result of inputting <em>C<sub>i new</sub></em> into the diffuse warp function after adding the stroke texture. As you can see, the noise gives a more random look to the edges of the ink chunks.</p>
<p><figure><img src="/img/portfolio/Unity-ink-%e6%bc%ab%e5%8f%8d%e5%b0%84%e5%8a%a0%e5%99%aa%e5%a3%b0%e7%bb%93%e6%9e%9c.png" width="550px"/>
</figure>

<br></p>
<p>After the above processing, I achieve the randomness of the edge of the mountains, but it still lacks the feeling of light ink spreading. To simulate the spreading and feathering, I introduce Gaussian blur for further processing.
I adjust the appropriate parameters, and the final blurred result is shown in the image. There is an obvious feathering edge at the junction of light and dark in the mountain rock.</p>
<p><figure><img src="/img/portfolio/Unity-ink-%e6%bc%ab%e5%8f%8d%e5%b0%84%e5%8a%a0%e5%99%aa%e5%a3%b0%e5%8a%a0%e9%ab%98%e6%96%af%e7%bb%93%e6%9e%9c.png" width="550px"/>
</figure>

<br></p>
<p>The flow map of the brush painting mountain and rock rendering scheme is as follows:</p>
<p><a href="/img/portfolio/Unity-ink-%E6%B0%B4%E5%A2%A8%E5%B1%B1%E7%9F%B3%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88.png"><img src="/img/portfolio/Unity-ink-%E6%B0%B4%E5%A2%A8%E5%B1%B1%E7%9F%B3%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88.png" alt="Snapshot 4 of Unity ink painting effect rendering VR scene"></a></p>
<p>Step-by-step output result of the scheme:</p>
<p><a href="/img/portfolio/Unity-ink-MountainStone.png"><img src="/img/portfolio/Unity-ink-MountainStone.png" alt="Snapshot 5 of Unity ink painting effect rendering VR scene"></a></p>
<figure><img src="/img/portfolio/Unity-ink-%e5%b1%b1%e7%9f%b3%e7%95%8c%e9%9d%a2%e6%88%aa%e5%9b%be.png"
         alt="A material panel in Unity" width="250px"/><figcaption>
            <p>A material panel in Unity</p>
        </figcaption>
</figure>

<h3 id="Chinese-Brush-Painting-Character-Rendering-Scheme">Chinese Brush Painting Character Rendering Scheme</h3>
<p>In the Chinese brush painting character rendering scheme, I propose a rendering method based on the viewing direction and bump map for contour rendering, that is, <strong>Surface Angle Silhouetting</strong>. A one-dimensional look-up table is used to map the results, so that the pleats of the clothes get a soft willow leaf drawing (柳叶描) effect, and normal scale is used to control the fineness of the stroke. In the internal coloring part, the grayscale adjustment of the color is realized. At the same time, a triplanar stroke map based on object space is proposed to simulate the effect of randomly splashing ink. Finally, the contour line, internal coloring and splashing ink strokes are mixed by texture blending.</p>
<p>On a smooth surface, the definition of point P on the Silhouette is <em><strong>v</strong></em> ∙ <em><strong>n</strong></em> =0.</p>
<p><figure><img src="/img/portfolio/Unity-ink-VdotN.png" width="300px"/>
</figure>

<br></p>
<p>But an actual 3D model is composed of many planes. What&rsquo;s more, in order to make the silhouette have a certain width, the judgment condition needs to be relaxed as follows:</p>
<div style="display: none">
<figure><img src="/img/portfolio/Unity-ink-%e4%ba%ba%e7%89%a9%e8%bd%ae%e5%bb%93%e7%ba%bf%e5%85%ac%e5%bc%8f.png" width="300px"/>
</figure>

<br>
</div>
<p>$$
\begin{align}
C_{edge}=\begin{cases}
1&amp;, &amp;\frac{|V \cdot N|}{r} &gt; t \cr
\left(\frac{|V \cdot N|}{r}\right)^{p}&amp;, &amp;\frac{|V \cdot N|}{r} \leq t
\end{cases}
\end{align}
$$</p>
<p>Among them, <em>C<sub>edge</sub></em> is the color of the contour; <em>r</em> can control the edge range, which can make the edge transition smoother; <em>t</em> controls the threshold; <em>p</em> is used to perform exponential operations on the edge and adjust the shade of edge color.</p>
<p>In order to narrow the gradient range between black and white, make the gradient range more natural, and simulate the effect of ink diffusion, I introduce a one-dimensional lookup table:</p>
<p><figure><img src="/img/portfolio/Unity-ink-1DLUT.jpg"/>
</figure>

<br></p>
<p>This one-dimensional lookup table has black on the left and white on the right, with very narrow gradients. This texture can also be seen as the result of Gaussian low-pass filtering preprocessing of an ordinary stepped lookup table. When in use, take the value of <em>C<sub>edge</sub></em> as input, and use this ramp texture for warping. The final effect is as follows:</p>
<figure><img src="/img/portfolio/Unity-ink-%e4%ba%ba%e7%89%a9%e8%bd%ae%e5%bb%93abcde.png"
         alt="a) The original model shaded according to the Blinn-Phong lighting model; b) The result of v ∙ n; c) The result of calculating Cedge; d) Silhouette after texture warping; e ) Silhouette with normal map (final result for Silhouette)"/><figcaption>
            <p>a) The original model shaded according to the Blinn-Phong lighting model; b) The result of <em><strong>v</strong></em> ∙ <em><strong>n</strong></em>; c) The result of calculating <em>Cedge</em>; d) Silhouette after texture warping; e ) Silhouette with normal map (final result for Silhouette)</p>
        </figcaption>
</figure>

<p>The relevant shader code is as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>fixed vdotn = <span style="color:#ff0086;font-weight:bold">abs</span>(<span style="color:#ff0086;font-weight:bold">dot</span>(viewDir, bump));
</span></span><span style="display:flex;"><span>fixed edge = vdotn / _Range;
</span></span><span style="display:flex;"><span>edge = edge &gt; _Thred ? <span style="color:#0086f7;font-weight:bold">1</span> : edge;
</span></span><span style="display:flex;"><span>edge = <span style="color:#ff0086;font-weight:bold">pow</span>(edge, _Pow);
</span></span><span style="display:flex;"><span>fixed4 edgeColor = <span style="color:#ff0086;font-weight:bold">tex2D</span>(_SilhouetteRampTex, <span style="color:#ff0086;font-weight:bold">fixed2</span>(edge, <span style="color:#0086f7;font-weight:bold">0.5</span>));</span></span></code></pre></div>
<p>For the internal coloring of the character, I use some empirical tricks to reduce the saturation and increase the brightness. I also make a splashed ink stroke texture. So I have silhouettes, interior textures, and strokes. The next step is to blend them together to get the final result.</p>
<p>Contour lines and internal textures are blended using an interpolation algorithm.</p>
<div style="display:none">
<figure><img src="/img/portfolio/Unity-ink-%e8%bd%ae%e5%bb%93%e7%ba%bf%e5%92%8c%e5%86%85%e9%83%a8%e7%ba%b9%e7%90%86%e5%b7%ae%e5%80%bc%e5%85%ac%e5%bc%8f.png" width="300px"/>
</figure>

<br>
</div>
<p>$$
\begin{align}
Output = \left ( 1-\lambda  \right ) \cdot edgecolor + \lambda \cdot innercolor, 0 &lt; \lambda &lt; 1
\end{align}
$$</p>
<div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#080;background-color:#0f140f;font-style:italic">// col is the internal shading result
</span></span></span><span style="display:flex;"><span><span style="color:#080;background-color:#0f140f;font-style:italic"></span>col = edgeColor &gt; col ? col : edgeColor * (<span style="color:#0086f7;font-weight:bold">1</span> - edge) + col * edge;
</span></span><span style="display:flex;"><span>col = <span style="color:#ff0086;font-weight:bold">pow</span>(col, _ColorPow);
</span></span><span style="display:flex;"><span><span style="color:#fb660a;font-weight:bold">return</span> col;</span></span></code></pre></div>
<p>Among them, <em>edgecolor</em> is the silhouette color and <em>innercolor</em> is the inner texture color. The difference coefficient <em>λ</em> is <em>C<sub>edge</sub></em>, which is the input of the one-dimensional lookup table. As a result, the silhouette blends well with the texture and has soft feathering edges. The shape of the contour line is similar to the &ldquo;willow-leaf-shaped stroke&rdquo;(柳叶描).</p>
<p><figure><img src="/img/portfolio/Unity-ink-%e8%bd%ae%e5%bb%93%e7%ba%bf%e5%92%8c%e5%86%85%e9%83%a8%e7%ba%b9%e7%90%86%e5%b7%ae%e5%80%bc%e7%bb%93%e6%9e%9c.png"
         alt="Left: the blending result; Right: zoomed-in pleats" width="400px"/><figcaption>
            <p><strong>Left</strong>: the blending result; <strong>Right</strong>: zoomed-in pleats</p>
        </figcaption>
</figure>

<br></p>
<p>The blend mode with splash stroke is Multiply. It examines the information in each color channel of the images and performs multiplying processing. The algorithm is as follows:</p>
<div style="display:none">
<figure><img src="/img/portfolio/Unity-ink-%e6%ad%a3%e7%89%87%e5%8f%a0%e5%ba%95%e5%85%ac%e5%bc%8f.png" width="300px"/>
</figure>

<br>
</div>
<p>$$
\begin{align}
Output = brushcolor \otimes innercolor
\end{align}
$$</p>
<p>This algorithm has low complexity and fast operation speed, and each pixel retains the information of splash stroke and internal texture. Since the multiplication of colors is equivalent to the darkening of both colors, the brighter inner texture can be suppressed to the normal brightness range.</p>
<p><figure><img src="/img/portfolio/Unity-ink-%e6%ad%a3%e7%89%87%e5%8f%a0%e5%ba%95%e7%bb%93%e6%9e%9c.png"
         alt="The output result after blending with splash stroke" width="250px"/><figcaption>
            <p>The output result after blending with splash stroke</p>
        </figcaption>
</figure>

<br></p>
<p>After blending the silhouette, internal textures and strokes, Post Processing is overlaid, and the final render is shown in the image.</p>
<p><figure><img src="/img/portfolio/Unity-ink-%e6%ad%a3%e7%89%87%e5%8f%a0%e5%ba%95%e5%92%8c%e5%90%8e%e5%a4%84%e7%90%86%e7%bb%93%e6%9e%9c.png" width="250px"/>
</figure>

<br></p>
<p>The solution has the following advantages in terms of rendering performance:</p>
<ol>
<li>The contour lines are more detailed and natural, especially the clothing part. The color of the line is darker, the edge transition is smoother, and there is no hard cutting edge, which corresponds to the effect of the outline drawn by the center of the brush.</li>
<li>The distribution of splash stroke textures is more in line with common sense, and there will be no complete symmetry or the situation where the strokes of two adjacent parts are completely disconnected.
At the same time, because of the above advantages, the rendering results look smoother and more flexible, and the distribution of ink colors is more natural, and more volumetric, even though I don&rsquo;t use any lighting models.</li>
</ol>
<p>The flow map of the brush painting character rendering scheme is as follows:</p>
<p><a href="/img/portfolio/Unity-ink-%E4%BA%BA%E7%89%A9%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88.png"><img src="/img/portfolio/Unity-ink-%E4%BA%BA%E7%89%A9%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88.png" alt="Snapshot 6 of Unity ink painting effect rendering VR scene"></a></p>
<p>Step-by-step output result of the scheme:</p>
<p><a href="/img/portfolio/Unity-ink-MonkeyKing.png"><img src="/img/portfolio/Unity-ink-MonkeyKing.png" alt="Snapshot 7 of Unity ink painting effect rendering VR scene"></a></p>
<figure><img src="/img/portfolio/Unity-ink-%e4%ba%ba%e7%89%a9%e7%95%8c%e9%9d%a2%e6%88%aa%e5%9b%be.png"
         alt="A material panel in Unity" width="250px"/><figcaption>
            <p>A material panel in Unity</p>
        </figcaption>
</figure>

<h2 id="Unity-VR">Unity VR Integration</h2>
<p>In Unity 2019.3, Unity has developed a new plug-in framework called XR SDK that enables XR providers to integrate with the Unity engine and make full use of its features. For more information, please refer to the <a href="https://docs.unity3d.com/2019.3/Documentation/Manual/XR.html">official user manual</a>.</p>
<p>Notably, Unity 2019.3 features a brand-new XR plug-in framework. The multi-platform developer tools include AR Foundation and <a href="https://docs.unity3d.com/Packages/com.unity.xr.interaction.toolkit@1.0/manual/index.html">XR Interaction Toolkit (XRI)</a>. Additionally, XR providers&rsquo; plug-ins can be loaded using Unity&rsquo;s package manager, making performance optimization easier with the engine&rsquo;s convenience.</p>
<p>Traditional development requires developers to adapt to different VR platforms, which means adapting input/output, display, and functionality, including a lot of repetitive labor. With XRI, developers can directly bridge with hardware through the XR plug-in provided by hardware vendors, without worrying about platform adaptation issues. This enables &ldquo;build once, deploy anywhere&rdquo;.</p>
<figure><img src="/img/portfolio/Unity-ink-xr-tech-stack.png"
         alt="This diagram illustrates the current Unity XR plug-in framework structure, and how it works with platform provider implementations." width="600px"/><figcaption>
            <p>This diagram illustrates the current Unity XR plug-in framework structure, and how it works with platform provider implementations.</p>
        </figcaption>
</figure>

<p>I choose Oculus Rift S as a verification and display device, with most of the work being done in the engine. This project uses Unity 2019.3&rsquo;s latest plugin architecture and XR Plug-in Management to load, initialize, set up, and manage plugins.</p>
<p><figure><img src="/img/portfolio/Unity-ink-vr-oculus-packages.png"/>
</figure>

<br></p>
<p>Since XRI in Unity 2019.3 is still in preview version (1.0.0-pre.2) and has not been officially released (note: it is officially released NOW), I use Virtual Reality Toolkit (VRTK) to replace its functionality. The disadvantage of VRTK is that bridging needs to be done manually, while XRI does it automatically.</p>
<p><figure><img src="/img/portfolio/Unity-ink-VRTK.png"
         alt="Manually bridge using VRTK" width="600px"/>
</figure>

<br></p>
<p>During the bridging process, to bridge the display and input of Oculus and VRTK, several packages are required, including <strong>Zinnia.Unity</strong>, <strong>Malimbe</strong>, and <strong>VRTK Prefabs</strong>. They can be easily imported and managed using Unity&rsquo;s package manager.</p>
<p>All input actions such as grabbing are handled by the VRTK package without having to worry about hardware implementation. The prefab used is &ldquo;<strong>Interactable.Primary_Grab.Secondary_Swap</strong>&rdquo; with the primary script being <strong>Interactable Facade.cs</strong>.</p>
<figure><img src="/img/portfolio/Unity-ink-facade.png"
         alt="The grabbable object can be placed as a child object under the prefab key.Interactable.Primary_Grab.Secondary_Swap." width="600px"/><figcaption>
            <p>The grabbable object can be placed as a child object under the prefab <strong>key.Interactable.Primary_Grab.Secondary_Swap</strong>.</p>
        </figcaption>
</figure>

<figure><img src="/img/portfolio/Unity-ink-facade1.png"
         alt="Get the grab action by adding listeners in the Grab Events." width="250px"/><figcaption>
            <p>Get the grab action by adding listeners in the <strong>Grab Events</strong>.</p>
        </figcaption>
</figure>

<h2 id="Gameplay">Gameplay</h2>
<p>Now that the hardware inputs and outputs are in place, the next step is the writing of the gameplay section.</p>
<h3 id="Scripts">Scripts  Architecture Overview</h3>
<p>The architecture designed for this project is shown in the figure below:</p>
<p><figure><img src="/img/portfolio/Unity-ink-structure-of-scripts.png"
         alt="architecture of scripts" width="350px"/>
</figure>

<br></p>
<p>The functions of each script are as follows:</p>
<ol>
<li>
<p><em><strong>InputHandler.cs</strong></em>: Determines the action of taking off the VR glasses, which triggers the transition from the first scene to the second scene.</p>
</li>
<li>
<p><em><strong>MainLogicController.cs</strong></em>: Handles all scene transitions.</p>
</li>
<li>
<p><em><strong>OtherCharacter</strong></em>: Manages the Non-player characters, especially the burning effect (using a shader parameter).</p>
</li>
<li>
<p><em><strong>GrabbableGlasses</strong></em>: Handles the action of grabbing the NPC&rsquo;s glasses in the second scene, triggers the transition from the second scene to the third scene, and manages the action of dropping the glasses to the ground when the character burns out.</p>
</li>
<li>
<p><em><strong>FadeParticle.cs</strong></em>: Manages the particle animation during NPC burning.</p>
</li>
<li>
<p><em><strong>SpeechManager</strong></em>: Manages dialogues between the player and NPC.</p>
</li>
<li>
<p><em><strong>QuitButton</strong></em>: Handles the transition from the third scene to the credits scene and quitting the game.</p>
</li>
</ol>
<p>Among them, 1 and 3, 4, 5 will be discussed in the <a href="#Gameplay">Gameplay</a> section; 2 will be discussed in the <a href="#Transition">Scene Transition Design</a> section; and 6 will be discussed in the <a href="#UI">Dialogue and UI Design</a> section.</p>
<h3 id="Gameplay-Scripts">Analysis of Gameplay Scripts</h3>
<p><em><strong>InputHandler.cs</strong></em> primarily handles the action recognition for <strong>removing the VR headset from the player</strong>, with the corresponding code shown below.</p>
<div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#cdcaa9;font-weight:bold">void</span> <span style="color:#ff0086;font-weight:bold">Update</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    isIndexPressed = OVRInput.<span style="color:#ff0086;font-weight:bold">Get</span>(OVRInput.RawButton.RIndexTrigger);
</span></span><span style="display:flex;"><span>    isMiddlePressed = OVRInput.<span style="color:#ff0086;font-weight:bold">Get</span>(OVRInput.RawButton.RHandTrigger);
</span></span><span style="display:flex;"><span>    handVelocityR = OVRInput.<span style="color:#ff0086;font-weight:bold">GetLocalControllerVelocity</span>(OVRInput.Controller.RHand);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#cdcaa9;font-weight:bold">bool</span> <span style="color:#ff0086;font-weight:bold">isLiftingGlass</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#cdcaa9;font-weight:bold">bool</span> isCorrectVelocity = handVelocityR.y &gt;= liftGlassThresholdY &amp;&amp;
</span></span><span style="display:flex;"><span>        Vector3.<span style="color:#ff0086;font-weight:bold">Angle</span>(handVelocityR, Vector3.up) &lt;= liftGlassThresholdAngle;
</span></span><span style="display:flex;"><span>    <span style="color:#cdcaa9;font-weight:bold">bool</span> isCorrectDistance = Vector3.<span style="color:#ff0086;font-weight:bold">Distance</span>(headTrans.position, rHandTrans.position) &lt;= liftGlassThresholdDistance;
</span></span><span style="display:flex;"><span>    <span style="color:#fb660a;font-weight:bold">return</span> isCorrectDistance &amp;&amp; isCorrectVelocity;         
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#cdcaa9;font-weight:bold">bool</span> <span style="color:#ff0086;font-weight:bold">isHandAtRight</span>() {
</span></span><span style="display:flex;"><span>    Vector3 eyeFront = headTrans.forward;
</span></span><span style="display:flex;"><span>    Vector3 eyeToHand = rHandTrans.position - headTrans.position;
</span></span><span style="display:flex;"><span>    <span style="color:#080;background-color:#0f140f;font-style:italic">// Unity uses left-handed coordinates
</span></span></span><span style="display:flex;"><span><span style="color:#080;background-color:#0f140f;font-style:italic"></span>    <span style="color:#fb660a;font-weight:bold">return</span> Vector3.<span style="color:#ff0086;font-weight:bold">Cross</span>(eyeToHand, eyeFront).y &lt; <span style="color:#0086f7;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>public <span style="color:#fb660a;font-weight:bold">static</span> <span style="color:#cdcaa9;font-weight:bold">bool</span> <span style="color:#ff0086;font-weight:bold">IsHandAtRight</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#fb660a;font-weight:bold">return</span> instance.<span style="color:#ff0086;font-weight:bold">isHandAtRight</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>public <span style="color:#fb660a;font-weight:bold">static</span> <span style="color:#cdcaa9;font-weight:bold">bool</span> <span style="color:#ff0086;font-weight:bold">IsLiftingGlass</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#fb660a;font-weight:bold">return</span> instance.<span style="color:#ff0086;font-weight:bold">isLiftingGlass</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>public <span style="color:#fb660a;font-weight:bold">static</span> <span style="color:#cdcaa9;font-weight:bold">bool</span> <span style="color:#ff0086;font-weight:bold">IsGrabbingR</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#fb660a;font-weight:bold">return</span> instance.isIndexPressed &amp;&amp; instance.isMiddlePressed;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>As you can see, there are three conditions involved: the hand is on the right side of the headset, a fist grab action, and a hand lift action. Based on this, the scene transition is triggered in <em>MainlogicController.cs</em>.</p>
<div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>            <span style="color:#fb660a;font-weight:bold">if</span> (canSceneSwap &amp;&amp; !isForcedWaiting)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#fb660a;font-weight:bold">if</span> ((InputHandler.<span style="color:#ff0086;font-weight:bold">IsGrabbingR</span>() 
</span></span><span style="display:flex;"><span>                    &amp;&amp; InputHandler.<span style="color:#ff0086;font-weight:bold">IsLiftingGlass</span>()
</span></span><span style="display:flex;"><span>                    &amp;&amp; InputHandler.<span style="color:#ff0086;font-weight:bold">IsHandAtRight</span>()) || Input.<span style="color:#ff0086;font-weight:bold">GetKeyUp</span>(<span style="color:#0086d2">&#34;space&#34;</span>))
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    <span style="color:#ff0086;font-weight:bold">StartSceneSwap</span>();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }</span></span></code></pre></div>
<p><em><strong>OtherCharacter.cs</strong></em>, which is responsible for handling the NPC burn effect, controls the dissolve progress of the NPC material by manipulating the exposed <strong>_Dissolve</strong> parameter in the shader. I created a simple dissolve effect by generating Perlin noise in the shader.</p>
<div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#cdcaa9;font-weight:bold">void</span> <span style="color:#ff0086;font-weight:bold">Update</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fb660a;font-weight:bold">if</span> (isFading &amp;&amp; dissolve &lt; <span style="color:#0086f7;font-weight:bold">1f</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        dissolve = Mathf.<span style="color:#ff0086;font-weight:bold">Clamp</span>(dissolve + dissolveSpeed * Time.deltaTime, <span style="color:#0086f7;font-weight:bold">0f</span>, <span style="color:#0086f7;font-weight:bold">1f</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#fb660a;font-weight:bold">for</span>(<span style="color:#cdcaa9;font-weight:bold">int</span> i = <span style="color:#0086f7;font-weight:bold">0</span>; i &lt; relatedMaterials.Length; i++) {
</span></span><span style="display:flex;"><span>            relatedMaterials[i].<span style="color:#ff0086;font-weight:bold">SetFloat</span>(<span style="color:#0086d2">&#34;_Dissolve&#34;</span>, dissolve);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff0086;font-weight:bold">foreach</span>(FadeParticle sys in pSystem) {
</span></span><span style="display:flex;"><span>            <span style="color:#fb660a;font-weight:bold">if</span> (sys != null)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                sys.<span style="color:#ff0086;font-weight:bold">SetValue</span>(<span style="color:#0086f7;font-weight:bold">1</span> - dissolve);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>public <span style="color:#cdcaa9;font-weight:bold">void</span> <span style="color:#ff0086;font-weight:bold">onGrabbed</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    isFading = true;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    Debug.<span style="color:#ff0086;font-weight:bold">Log</span>(<span style="color:#0086d2">&#34;Grabbed glasses&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>public <span style="color:#cdcaa9;font-weight:bold">void</span> <span style="color:#ff0086;font-weight:bold">onGrabbedSelf</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#ff0086;font-weight:bold">onGrabbed</span>();
</span></span><span style="display:flex;"><span>    glasses.transform.<span style="color:#ff0086;font-weight:bold">SetParent</span>(null);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="UI">UI Design</h2>
<p>In VR scenes, two display modes were used for UI.</p>
<ol>
<li>For my part in the dialogue, the canvas is fixed directly on the CenterEyeAnchor as a screen space UI (note that the render mode I choose is still world space, but it will look like screen space as it follows the movement of tracking);</li>
</ol>
<figure><img src="/img/portfolio/Unity-ink-myUI.png"
         alt="There are two Texts here, one for the dialogue and one for displaying Credits at the end of the process." width="600px"/><figcaption>
            <p>There are two Texts here, one for the dialogue and one for displaying Credits at the end of the process.</p>
        </figcaption>
</figure>

<ol start="2">
<li>For others&rsquo; part in the dialogue, the canvas is displayed above their respective heads as a world space UI.</li>
</ol>
<p><figure><img src="/img/portfolio/Unity-ink-othersUI.png" width="600px"/>
</figure>

<br></p>
<p>I rewrote the UIDefault.shader in Unity&rsquo;s built-in shader and added a billboard function that allows it to rotate and always face the player&rsquo;s line of sight.</p>
<p>In the billboard code section, a coordinate system needs to be create first. But how to define the &ldquo;front&rdquo; direction of the coordinates?</p>
<p>The traditional method is to use the &ldquo;<em>viewer minus center</em>&rdquo; vector, but this can cause significant distortion at the edge of the viewing frustum.</p>
<p><figure><img src="/img/portfolio/Unity-ink-UI1.GIF"
         alt="*viewer minus center* as front" width="400px"/>
</figure>

<br></p>
<p>I try to use the &ldquo;forward direction of the camera&rdquo;, namely the <code>UNITY_MATRIX_IT_MV[2].xyz</code> macro. This way, no matter if it&rsquo;s at the edge of the viewing frustum or in the center of the screen, the text will face the viewer directly.</p>
<p><figure><img src="/img/portfolio/Unity-ink-UI2.GIF"
         alt="forward direction of the camera" width="400px"/>
</figure>

<br></p>
<p>For traditional displays, I prefer the second method. Without distortion, it feels more &ldquo;UI&rdquo;. In VR, however, it feels weird. After experimenting, I choose the first method in the VR scene.</p>
<h2 id="Transition">Scene Transition Design</h2>
<p>The 2022 game <em>God of War Ragnarök</em> features an impressive one-shot design that seamlessly blends over 20 hours of gameplay into a cohesive experience. Many games, not just those in the <em>God of War</em> series, strive to make loading and scene transitions as seamless as possible. In my VR experience, I have three scenes with very different styles, so reducing the &ldquo;jumpiness&rdquo; of the gameplay experience and minimizing the &ldquo;stuttering&rdquo; of loading screens to alleviate VR sickness is a design focus.</p>
<p>To achieve a smoother transition, I use two effects in combination: fog and scene darkening. I create the fog particle effect and attach it as a child object to the OVRCameraRig&rsquo;s CenterEyeAnchor. I mainly control the density of the fog by scripting the <strong>Rate over Time</strong> parameter of particle emission. For the darkening effect, I use Unity&rsquo;s Post Processing Stack to control the <strong>Exposure Compensation</strong>.</p>
<div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#cdcaa9;font-weight:bold">void</span> <span style="color:#ff0086;font-weight:bold">HandleParticles</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fb660a;font-weight:bold">if</span> (particleRatio &lt;= <span style="color:#0086f7;font-weight:bold">0</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        particleRatio = <span style="color:#0086f7;font-weight:bold">0f</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fb660a;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        particleRatio = Mathf.<span style="color:#ff0086;font-weight:bold">Clamp</span>(particleRatio - particleFadeRatio * Time.deltaTime, <span style="color:#0086f7;font-weight:bold">0f</span>, <span style="color:#0086f7;font-weight:bold">1f</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff0086;font-weight:bold">foreach</span>(ParticleStruct ps in fadeParticleSys)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        ps.<span style="color:#ff0086;font-weight:bold">SetRate</span>(particleRatio);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;background-color:#0f140f;font-style:italic">// The Adaptation Type is Progressive by default
</span></span></span><span style="display:flex;"><span><span style="color:#080;background-color:#0f140f;font-style:italic"></span>    <span style="color:#080;background-color:#0f140f;font-style:italic">// so there is no need to animate autoExposure to make it linear
</span></span></span><span style="display:flex;"><span><span style="color:#080;background-color:#0f140f;font-style:italic"></span>    <span style="color:#080;background-color:#0f140f;font-style:italic">// The adaptation speed can be adjusted directly in the Inspector panel of Post-process Volume
</span></span></span><span style="display:flex;"><span><span style="color:#080;background-color:#0f140f;font-style:italic"></span>    <span style="color:#fb660a;font-weight:bold">if</span> (!canSceneSwap || isForcedWaiting)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        autoExposure.keyValue.<span style="color:#ff0086;font-weight:bold">Override</span>(<span style="color:#0086f7;font-weight:bold">0f</span>);   
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fb660a;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        autoExposure.keyValue.<span style="color:#ff0086;font-weight:bold">Override</span>(<span style="color:#0086f7;font-weight:bold">1f</span>);   
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>public class ParticleStruct
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ParticleSystem system;
</span></span><span style="display:flex;"><span>    <span style="color:#cdcaa9;font-weight:bold">float</span> initEmission;
</span></span><span style="display:flex;"><span>    public <span style="color:#ff0086;font-weight:bold">ParticleStruct</span>(ParticleSystem _system)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        system = _system;
</span></span><span style="display:flex;"><span>        initEmission = _system.emission.rateOverTime.constant;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    public <span style="color:#cdcaa9;font-weight:bold">void</span> <span style="color:#ff0086;font-weight:bold">SetRate</span>(<span style="color:#cdcaa9;font-weight:bold">float</span> rate)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        var emit = system.emission;
</span></span><span style="display:flex;"><span>        emit.rateOverTime = rate * initEmission;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>After the scene transition action is performed, there is a wait for the animation to play. Scene transitions are done asynchronously using coroutines to avoid the screen lagging caused by scene changes and mismatched headset movements, which could lead to VR sickness.</p>
<div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#111;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#cdcaa9;font-weight:bold">void</span> <span style="color:#ff0086;font-weight:bold">SceneSwap</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    canSceneSwap = false;
</span></span><span style="display:flex;"><span>    <span style="color:#cdcaa9;font-weight:bold">bool</span> found = false;
</span></span><span style="display:flex;"><span>    <span style="color:#cdcaa9;font-weight:bold">int</span> sceneCount = scenes.Length;
</span></span><span style="display:flex;"><span>    <span style="color:#fb660a;font-weight:bold">if</span> (sceneCount &lt;= <span style="color:#0086f7;font-weight:bold">1</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Debug.<span style="color:#ff0086;font-weight:bold">LogError</span>(<span style="color:#0086d2">&#34;No scenes appointed&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#fb660a;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#fb660a;font-weight:bold">for</span> (<span style="color:#cdcaa9;font-weight:bold">int</span> i = <span style="color:#0086f7;font-weight:bold">0</span>; i &lt; sceneCount; i++)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#fb660a;font-weight:bold">if</span> (scenes[i] == SceneManager.<span style="color:#ff0086;font-weight:bold">GetActiveScene</span>().name)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#fb660a;font-weight:bold">if</span> (i == <span style="color:#0086f7;font-weight:bold">1</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                particleFadeRatio = particleFadeRatioAlternate;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            found = true;
</span></span><span style="display:flex;"><span>            sceneSwapProgress = SceneManager.<span style="color:#ff0086;font-weight:bold">LoadSceneAsync</span>(scenes[(i + <span style="color:#0086f7;font-weight:bold">1</span>) % sceneCount]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fb660a;font-weight:bold">if</span> (!found)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        sceneSwapProgress = SceneManager.<span style="color:#ff0086;font-weight:bold">LoadSceneAsync</span>(scenes[<span style="color:#0086f7;font-weight:bold">0</span>]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;background-color:#0f140f;font-style:italic">// For the transition from Scene 2 to Scene 3
</span></span></span><span style="display:flex;"><span><span style="color:#080;background-color:#0f140f;font-style:italic">// in addition to waiting for the fog to thicken at the transition
</span></span></span><span style="display:flex;"><span><span style="color:#080;background-color:#0f140f;font-style:italic">// there is also a waiting period for the character to burn and dissolve and glasses to fall off
</span></span></span><span style="display:flex;"><span><span style="color:#080;background-color:#0f140f;font-style:italic">// which is an additional 8 seconds (pickGlassSceneSwapDelay)
</span></span></span><span style="display:flex;"><span><span style="color:#080;background-color:#0f140f;font-style:italic"></span>public <span style="color:#cdcaa9;font-weight:bold">void</span> <span style="color:#ff0086;font-weight:bold">StartDelayedSceneSwapAfterPickup</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#ff0086;font-weight:bold">StartCoroutine</span>(<span style="color:#0086d2">&#34;DelayedSceneSwapAfterPickup&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>public IEnumerator <span style="color:#ff0086;font-weight:bold">DelayedSceneSwapAfterPickup</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    yield <span style="color:#fb660a;font-weight:bold">return</span> new <span style="color:#ff0086;font-weight:bold">WaitForSeconds</span>(pickGlassSceneSwapDelay);
</span></span><span style="display:flex;"><span>    <span style="color:#ff0086;font-weight:bold">StartSceneSwap</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;background-color:#0f140f;font-style:italic">// For the transition from Scene 1 to Scene 2
</span></span></span><span style="display:flex;"><span><span style="color:#080;background-color:#0f140f;font-style:italic">// it takes 3 seconds (minWaitTime) to wait for the fog to thicken and the scene to darken
</span></span></span><span style="display:flex;"><span><span style="color:#080;background-color:#0f140f;font-style:italic"></span>public <span style="color:#cdcaa9;font-weight:bold">void</span> <span style="color:#ff0086;font-weight:bold">StartSceneSwap</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#ff0086;font-weight:bold">StartCoroutine</span>(<span style="color:#0086d2">&#34;ForcedWait&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>IEnumerator <span style="color:#ff0086;font-weight:bold">ForcedWait</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    canSceneSwap = false;
</span></span><span style="display:flex;"><span>    isForcedWaiting = true;
</span></span><span style="display:flex;"><span>    particleRatio = <span style="color:#0086f7;font-weight:bold">1f</span>;
</span></span><span style="display:flex;"><span>    yield <span style="color:#fb660a;font-weight:bold">return</span> new <span style="color:#ff0086;font-weight:bold">WaitForSeconds</span>(minWaitTime);
</span></span><span style="display:flex;"><span>    isForcedWaiting = false;
</span></span><span style="display:flex;"><span>    <span style="color:#ff0086;font-weight:bold">SceneSwap</span>();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p><figure><img src="/img/portfolio/Unity-ink-scene-swap.png"
         alt="Scene Transition" width="400px"/>
</figure>

<br></p>
<h3 id="Blooper">Blooper</h3>
<p>These are some screenshots taken during the development process. Just want to find an opportunity to showcase the Kawaii Unity Chan😊.</p>
<figure><img src="/img/portfolio/Unity-ink-UnityChan.gif"
         alt="Unity Chan, with wind effects applied to her hair and skirt using Magica Cloth." width="300px"/><figcaption>
            <p>Unity Chan, with wind effects applied to her hair and skirt using Magica Cloth.</p>
        </figcaption>
</figure>

<figure><img src="/img/portfolio/Unity-ink-UnityChan2.jpg"
         alt="Adding post-process effects to mimic Xuan paper texture." width="600px"/><figcaption>
            <p>Adding post-process effects to mimic Xuan paper texture.</p>
        </figcaption>
</figure>


         
      </div>
    </div>
  </div>
</div>

          </div>
      </div>
  </div>
  <script src="https://cindy-cao-portfolio.netlify.app/js/jquery.min.js"></script>
<script src="https://cindy-cao-portfolio.netlify.app/js/bootstrap.min.js"></script>
<script src="https://cindy-cao-portfolio.netlify.app/js/jquery.cookie.js"> </script>
<script src="https://cindy-cao-portfolio.netlify.app/js/ekko-lightbox.js"></script>
<script src="https://cindy-cao-portfolio.netlify.app/js/jquery.scrollTo.min.js"></script>
<script src="https://cindy-cao-portfolio.netlify.app/js/masonry.pkgd.min.js"></script>
<script src="https://cindy-cao-portfolio.netlify.app/js/imagesloaded.pkgd.min.js"></script>
<script src="https://cindy-cao-portfolio.netlify.app/js/owl.carousel.min.js"></script>
<script src="https://cindy-cao-portfolio.netlify.app/js/front.js"></script>



</body>
</html>
